# バックテスト最適化設計書

## 目的

過去データを用いて、スイングトレード推奨システムの指標重み付けを最適化し、最も高い勝率・リターンを達成する

---

## 1. 最適化の目標関数

### 主要指標（複合スコア）

```python
optimization_score = (
    win_rate * 0.35 +                    # 勝率 (35%)
    profit_factor * 0.25 +               # プロフィットファクター (25%)
    sharpe_ratio * 0.20 +                # シャープレシオ (20%)
    (1 - max_drawdown) * 0.15 +          # 最大ドローダウン (15%)
    avg_holding_days_score * 0.05        # 保有期間適合性 (5%)
)
```

### 各指標の定義

| 指標 | 計算式 | 目標値 | 重要度 |
|-----|--------|-------|--------|
| **勝率 (Win Rate)** | 利益トレード数 / 総トレード数 | > 60% | 35% |
| **プロフィットファクター** | 総利益 / 総損失 | > 2.0 | 25% |
| **シャープレシオ** | (平均リターン - 無リスク金利) / リターン標準偏差 | > 1.5 | 20% |
| **最大ドローダウン** | 最大下落率 | < 15% | 15% |
| **平均保有日数** | 3-15日の範囲内か | 3-15日 | 5% |

### なぜこの複合スコアか

- **勝率だけでは不十分**: 高勝率でも利小損大では意味がない
- **プロフィットファクター**: 利益の質を測定（損失1に対して利益2以上が理想）
- **シャープレシオ**: リスク調整後リターン（ボラティリティ考慮）
- **ドローダウン**: 最悪期の損失を抑制（心理的耐性）
- **保有期間**: スイングトレード適性の確認

---

## 2. 最適化パラメータ空間

### 最適化する重み付け

```python
OPTIMIZATION_PARAMS = {
    'trend_weight': [0.20, 0.25, 0.30, 0.35, 0.40],           # トレンド
    'momentum_weight': [0.15, 0.20, 0.25, 0.30, 0.35],        # モメンタム
    'volume_weight': [0.10, 0.15, 0.20, 0.25, 0.30],          # 出来高
    'volatility_weight': [0.10, 0.15, 0.20, 0.25],            # ボラティリティ
    'pattern_weight': [0.05, 0.10, 0.15, 0.20],               # パターン
}

# 制約条件
CONSTRAINTS = {
    'sum_must_equal': 1.0,  # 合計100%
    'min_weight': 0.05,     # 最小5% (すべての要素を考慮)
    'max_weight': 0.45,     # 最大45% (過度な偏りを防止)
}
```

### 探索空間のサイズ

- グリッドサーチ: 5 × 5 × 5 × 4 × 4 = 2,000通り
- ただし制約条件で約500-800通りに絞り込まれる

---

## 3. バックテスト手法

### 3.1 データ分割戦略

**ウォークフォワード分析**で過学習を防止

```
全データ期間: 2022-01-01 ~ 2025-12-31 (4年間)

[Training Period 1]  [Test Period 1]
2022-01 ~ 2023-06    2023-07 ~ 2023-12  → 最適化 & 検証

[Training Period 2]  [Test Period 2]
2023-01 ~ 2024-06    2024-07 ~ 2024-12  → 再最適化 & 検証

[Training Period 3]  [Test Period 3]
2024-01 ~ 2025-06    2025-07 ~ 2025-12  → 再最適化 & 検証

最終評価: 3つのTest Periodの平均パフォーマンス
```

### 3.2 バックテストルール

**エントリー:**
- スコア65点以上の銘柄
- 1日あたり上位5銘柄まで
- 1銘柄あたり資金の20%まで配分

**イグジット:**
- 利益確定: +10% または +15%
- 損切り: ATR × 2 (約-4~6%)
- 時間切れ: 15日経過で強制決済
- 日次再評価: スコア50点未満で売却検討

**取引コスト:**
- 売買手数料: 片道0.1% (往復0.2%)
- スリッページ: 0.05%
- 総コスト: 約0.25%

**資金管理:**
- 初期資金: 1,000,000円
- 最大同時保有: 5銘柄
- リスク: 1トレードあたり資金の2%

---

## 4. 最適化アルゴリズム

### Phase 1: グリッドサーチ（粗探索）

```python
def grid_search_coarse():
    """
    全パラメータ組み合わせを試行
    制約条件を満たす組み合わせのみ実行
    """
    results = []

    for trend in [0.20, 0.25, 0.30, 0.35, 0.40]:
        for momentum in [0.15, 0.20, 0.25, 0.30, 0.35]:
            for volume in [0.10, 0.15, 0.20, 0.25, 0.30]:
                for volatility in [0.10, 0.15, 0.20, 0.25]:
                    pattern = 1.0 - (trend + momentum + volume + volatility)

                    # 制約チェック
                    if not (0.05 <= pattern <= 0.20):
                        continue

                    # バックテスト実行
                    weights = {
                        'trend': trend,
                        'momentum': momentum,
                        'volume': volume,
                        'volatility': volatility,
                        'pattern': pattern
                    }

                    score = run_backtest(weights)
                    results.append((weights, score))

    # 上位20組を次フェーズへ
    return sorted(results, key=lambda x: x[1], reverse=True)[:20]
```

### Phase 2: ベイズ最適化（精密探索）

```python
from sklearn.gaussian_process import GaussianProcessRegressor
from scipy.optimize import minimize

def bayesian_optimization(initial_results):
    """
    グリッドサーチの上位結果から開始
    ガウス過程で効率的に最適解を探索
    """
    # 初期データでガウス過程をトレーニング
    X = [list(r[0].values()) for r in initial_results]
    y = [r[1] for r in initial_results]

    gp = GaussianProcessRegressor()
    gp.fit(X, y)

    # 獲得関数（Expected Improvement）で次の候補を選択
    for iteration in range(50):
        next_params = select_next_sample(gp)
        score = run_backtest(next_params)

        # ガウス過程を更新
        gp.fit(X + [next_params], y + [score])

    return gp.best_params
```

**ベイズ最適化の利点:**
- グリッドサーチより少ない試行で最適解に到達
- 探索と活用のバランスを自動調整
- 連続的なパラメータ空間も探索可能

---

## 5. 評価プロセス

### 5.1 トレーニング期間での最適化

```python
def optimize_weights(training_data):
    """
    トレーニングデータで最適な重みを見つける
    """
    # Phase 1: グリッドサーチ
    top_20 = grid_search_coarse(training_data)

    # Phase 2: ベイズ最適化
    optimal_weights = bayesian_optimization(top_20, training_data)

    return optimal_weights
```

### 5.2 テスト期間での検証

```python
def validate_weights(optimal_weights, test_data):
    """
    テストデータで性能を検証（過学習チェック）
    """
    test_results = run_backtest(optimal_weights, test_data)

    # 性能低下チェック
    if test_results.win_rate < training_results.win_rate * 0.9:
        print("WARNING: Possible overfitting detected")

    return test_results
```

### 5.3 ロバストネステスト

**感度分析:**
```python
def sensitivity_analysis(optimal_weights):
    """
    最適重みの±5%範囲でパフォーマンスを確認
    安定性の高い重みを選定
    """
    for param in optimal_weights:
        for delta in [-0.05, -0.02, 0, +0.02, +0.05]:
            perturbed_weights = optimal_weights.copy()
            perturbed_weights[param] += delta

            score = run_backtest(perturbed_weights)
            print(f"{param} {delta:+.2f}: {score}")
```

**期間別パフォーマンス:**
- 上昇相場（2023年前半）
- 下落相場（2022年）
- レンジ相場（2024年）

各市場環境で安定したパフォーマンスを発揮する重みを選定

---

## 6. 実装計画

### 6.1 必要なコンポーネント

```
backtesting/
├── __init__.py
├── data_loader.py          # 過去データ取得・キャッシュ
├── indicator_engine.py     # テクニカル指標計算
├── scoring_engine.py       # スコアリングロジック
├── backtest_engine.py      # バックテストシミュレーション
├── optimizer.py            # 重み付け最適化
├── evaluator.py            # 性能評価・可視化
└── config.py               # バックテスト設定
```

### 6.2 実装ステップ

**Step 1: データ取得 (1-2日)**
- yfinanceで15銘柄×4年分のデータ取得
- OHLCV（始値・高値・安値・終値・出来高）
- ローカルキャッシュで高速化

**Step 2: 指標計算エンジン (2-3日)**
- pandas-taまたはta-libで全指標を計算
- SMA, EMA, RSI, MACD, Bollinger Bands, ATR, OBV
- ベクトル化で高速処理

**Step 3: バックテストエンジン (3-4日)**
- イベント駆動型シミュレーション
- エントリー/イグジットロジック
- ポートフォリオ管理（複数銘柄同時保有）
- パフォーマンス計測

**Step 4: 最適化エンジン (2-3日)**
- グリッドサーチ実装
- ベイズ最適化実装（scikit-optimize使用）
- 並列処理で高速化（multiprocessing）

**Step 5: 評価・可視化 (1-2日)**
- 性能レポート生成
- エクイティカーブ（資産推移）
- ドローダウンチャート
- トレード分析（勝率、平均利益/損失）

---

## 7. 期待される成果物

### 7.1 最適化結果レポート

```
=======================================================
重み付け最適化結果
=======================================================

【最適な重み付け】
トレンド        : 32.5%
モメンタム      : 27.0%
出来高          : 22.5%
ボラティリティ  : 12.5%
パターン        : 5.5%

【トレーニング期間パフォーマンス (2022-01 ~ 2023-06)】
勝率            : 64.2%
プロフィットF   : 2.35
シャープレシオ  : 1.82
最大DD          : -12.3%
平均保有日数    : 8.4日
総リターン      : +47.8%

【テスト期間パフォーマンス (2023-07 ~ 2023-12)】
勝率            : 61.8%
プロフィットF   : 2.18
シャープレシオ  : 1.65
最大DD          : -14.1%
総リターン      : +28.5%

【過学習チェック】
勝率低下        : -2.4% (許容範囲内)
安定性評価      : ★★★★☆

【感度分析】
トレンド重み ±5%   : スコア変動 ±1.2% (安定)
モメンタム重み ±5% : スコア変動 ±2.8% (やや敏感)
出来高重み ±5%     : スコア変動 ±1.5% (安定)

【推奨】
本重み付けを本番環境に採用
ただし3ヶ月ごとに再最適化を実施
=======================================================
```

### 7.2 トレード詳細ログ

```csv
date,symbol,entry_price,exit_price,return,holding_days,exit_reason
2023-07-15,7203.T,2450,2695,+10.0%,7,profit_target
2023-07-18,6758.T,12800,12450,-2.7%,4,stop_loss
...
```

### 7.3 可視化グラフ

1. **エクイティカーブ**: 資産推移と日経平均の比較
2. **ドローダウンチャート**: 最大下落期間の可視化
3. **月次リターン**: ヒートマップ表示
4. **勝率・PF推移**: 時系列での安定性確認
5. **重み付けヒートマップ**: 各組み合わせのスコア分布

---

## 8. リスクと対策

### リスク1: 過学習

**対策:**
- ウォークフォワード分析で3期間検証
- テスト期間でのパフォーマンス低下を10%以内に制限
- 感度分析で重みの安定性を確認

### リスク2: データ不足

**対策:**
- 最低2年分のデータを使用（約500営業日）
- 15銘柄 × 500日 = 7,500データポイント
- 十分な統計的有意性を確保

### リスク3: 市場環境変化

**対策:**
- 3ヶ月ごとに再最適化
- 複数の市場環境（上昇・下落・レンジ）でテスト
- アダプティブな重み調整機能を実装

### リスク4: 計算コスト

**対策:**
- グリッドサーチは粗探索のみ（500-800通り）
- ベイズ最適化で効率化（50-100回の評価）
- 並列処理（マルチコア活用）
- キャッシュで重複計算を回避

---

## 9. 次のアクション

1. **データ取得スクリプト実装** → 15銘柄 × 4年分
2. **指標計算モジュール実装** → pandas-ta活用
3. **バックテストエンジン実装** → シミュレーション
4. **最適化実行** → グリッドサーチ + ベイズ最適化
5. **結果分析** → 最適重みの決定
6. **設定ファイル更新** → 本番環境への反映

---

## 10. 成功基準

最適化が成功したと判断する基準:

✅ 勝率 > 60%
✅ プロフィットファクター > 2.0
✅ シャープレシオ > 1.5
✅ 最大ドローダウン < 15%
✅ テスト期間でのパフォーマンス低下 < 10%
✅ 3つの異なる期間で安定したパフォーマンス
✅ 感度分析で±5%の重み変動に対してスコア変動 < 5%

---

*このフレームワークに従って実装を進めます*
